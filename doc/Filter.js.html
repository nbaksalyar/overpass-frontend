<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Filter.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Filter.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>function qlesc (str) {
  return '"' + str.replace(/"/g, '\\"') + '"'
}

function compile (part) {
  switch (part.op) {
    case 'has_key':
      return '[' + qlesc(part.key) + ']'
    case '=':
    case '!=':
    case '~':
    case '!~':
      return '[' + qlesc(part.key) + part.op + qlesc(part.value) + ']'
    case 'has':
      return '[' + qlesc(part.key) + '~' + qlesc('^(.*;|)' + part.value + '(|;.*)$') + ']'
  }
}

function test (ob, part) {
  if (part.type) {
    return ob.type === part.type
  }

  switch (part.op) {
    case 'has_key':
      return ob.tags &amp;&amp; (part.key in ob.tags)
    case '=':
      return ob.tags &amp;&amp; (part.key in ob.tags) &amp;&amp; (ob.tags[part.key] === part.value)
    case '!=':
      return ob.tags &amp;&amp; (part.key in ob.tags) &amp;&amp; (ob.tags[part.key] !== part.value)
    case '~':
      return ob.tags &amp;&amp; (part.key in ob.tags) &amp;&amp; (ob.tags[part.key].match(part.value))
    case '!~':
      return ob.tags &amp;&amp; (part.key in ob.tags) &amp;&amp; (!ob.tags[part.key].match(part.value))
    case 'has':
      return ob.tags &amp;&amp; (part.key in ob.tags) &amp;&amp; (ob.tags[part.key].split(/;/).indexOf(part.value) !== -1)
    default:
      return false
  }
}

function parseString (str) {
  let result = ''
  let chr = str[0]
  str = str.slice(1)

  while (str.length) {
    let m = str.match('^[^\\\\' + chr + ']+')
    if (m) {
      result += m[0]
      str = str.slice(m[0].length)
    } else if (str[0] === '\\') {
      result += str[1]
      str = str.slice(2)
    } else if (str[0] === chr) {
      str = str.slice(1)
      return [ result, str ]
    } else {
      throw new Error("Can't parse string from query: " + str)
    }
  }
}

function parse (def) {
  let result = []

  let mode = 0
  let key
  let value
  let op
  let m
  while (def.length) {
    if (mode === 0) {
      m = def.match(/^\s*(node|way|relation|rel|nwr|\()/)
      if (m &amp;&amp; m[1] === '(') {
        def = def.slice(m[0].length)
        let parts = []

        do {
          let part

          [ part, def ] = parse(def)
          parts.push(part)
        } while (!def.match(/^\s*\)/))

        return [ { or: parts }, def ]
      } else if (m) {
        if (m[1] === 'rel') {
          result.push({ type: 'relation' })
        } else if (m[1] === 'nwr') {
            // nothing
        } else {
          result.push({ type: m[1] })
        }
        mode = 10
        def = def.slice(m[0].length)
      } else {
        throw new Error("Can't parse query, expected type of object (e.g. 'node'): " + def)
      }
    } else if (mode === 10) {
      let m = def.match(/^\s*(\[|;)/)
      if (m &amp;&amp; m[1] === '[') {
        def = def.slice(m[0].length)
        mode = 11
      } else if (m &amp;&amp; m[1] === ';') {
        def = def.slice(m[0].length)
        return [ result, def ]
      } else if (!m &amp;&amp; def.match(/^\s*$/)) {
        return [ result, '' ]
      } else {
        throw new Error("Can't parse query, expected '[' or ';': " + def)
      }
    } else if (mode === 11) {
      m = def.match(/^(\s*)([a-zA-Z0-9_]+|"|')/)
      if (m[2] === '"' || m[2] === "'") {
        def = def.slice(m[1].length)
        let x = parseString(def)
        key = x[0]
        def = x[1]
        mode = 12
      } else if (m) {
        key = m[2]
        def = def.slice(m[0].length)
        mode = 12
      } else {
        throw new Error("Can't parse query, expected key: " + def)
      }
    } else if (mode === 12) {
      m = def.match(/^\s*(=|!=|~|!~|\^|])/)
      if (m &amp;&amp; m[1] === ']') {
        result.push({ key, op: 'has_key' })
        def = def.slice(m[0].length)
        mode = 10
      } else if (m) {
        op = m[1] === '^' ? 'has' : m[1]
        mode = 13
        def = def.slice(m[0].length)
      } else {
        throw new Error("Can't parse query, expected operator or ']': " + def)
      }
    } else if (mode === 13) {
      m = def.match(/^(\s*)([a-zA-Z0-9_]+|"|')/)
      if (m &amp;&amp; (m[2] === '"' || m[2] === "'")) {
        def = def.slice(m[1].length)
        let x = parseString(def)
        value = x[0]
        def = x[1]
        mode = 14
      } else if (m) {
        value = m[2]
        def = def.slice(m[0].length)
        mode = 14
      } else {
        throw new Error("Can't parse query, expected value: " + def)
      }
    } else if (mode === 14) {
      m = def.match(/^\s*\]/)
      if (m) {
        result.push({ key, op, value })
        mode = 10
        def = def.slice(m[0].length)
      } else {
        throw new Error("Can't parse query, expected ']': " + def)
      }
    }
  }

  return [ result, def ]
}

/**
 * A Filter into OSM data. A simplified version of Overpass QL.
 * @param {string|object} query
 */
class Filter {
  constructor (def) {
    if (typeof def === 'string') {
      [ this.def ] = parse(def)
      return
    }

    this.def = def
  }

  /**
   * Check of a object matches this filter
   * @param {OverpassNode|OverpassWay|OverpassRelation} ob an object from Overpass API
   * @return {boolean}
   */
  match (ob, def) {
    if (!def) {
      def = this.def
    }

    if (def.or) {
      return def.or.some(part => this.match(ob, part))
    }

    return def.filter(test.bind(this, ob)).length === def.length
  }

  /**
   * Convert query to a string representation
   * @return {string}
   */
  toString (def) {
    let result = ''

    if (!def) {
      def = this.def
    }

    if (def.or) {
      return '(' + def.or.map(part => this.toString(part)).join(';') + ';)'
    }

    let parts = def.filter(part => part.type)

    switch (parts.length) {
      case 0:
        result = 'nwr'
        break
      case 1:
        result = parts[0].type
        break
      default:
        throw new Error('Filter: only one type query allowed!')
    }

    result += def
      .filter(part => !part.type)
      .map(compile).join('')

    return result
  }

  /**
   * Convert query to Overpass QL
   * @param {object} [options] Additional options
   * @param {string} [options.inputSet=''] Specify input set (e.g.'.foo').
   * @return {string}
   */
  toQl (options = {}, def) {
    if (!def) {
      def = this.def
    }

    if (!options.inputSet) {
      options.inputSet = ''
    }

    if (def.or) {
      return '(' + def.or.map(part => {
        let r = this.toQl(options, part)
        return r.slice(1, -1)
      }).join('') + ')'
    }

    let parts = def.filter(part => part.type)
    let types

    switch (parts.length) {
      case 0:
        types = [ 'node', 'way', 'relation' ]
        break
      case 1:
        types = [ parts[0].type ]
        break
      default:
        throw new Error('Filter: only one type query allowed!')
    }

    let filters = def.filter(part => !part.type)

    return '(' + types.map(type => type + options.inputSet + filters.map(compile).join('')).join(';') + ';)'
  }

  /**
   * Convert query to LokiJS query for local database
   * @param {object} [options] Additional options
   * @return {string}
   */
  toLokijs (options = {}, def) {
    if (!def) {
      def = this.def
    }

    if (def.or) {
      return { $or:
        def.or.map(part => {
          return this.toLokijs(options, part)
        })
      }
    }

    let query = {}

    def.forEach(filter => {
      let k, v
      if (filter.op === '=') {
        k = 'tags.' + filter.key
        v = filter.value
      } else if (filter.op === '!=') {
        k = 'tags.' + filter.key
        v = { $ne: filter.value }
      } else if (filter.op === 'has_key') {
        k = 'tags.' + filter.key
        v = { $exists: true }
      } else if (filter.op === 'has') {
        k = 'tags.' + filter.key
        v = { $regex: '^(.*;|)' + filter.value + '(|;.*)$' }
      } else if (filter.op === '~') {
        k = 'tags.' + filter.key
        v = { $regex: filter.value }
      } else if (filter.op === '!~') {
        k = 'tags.' + filter.key
        v = { $not: { $regex: filter.value } }
      } else if (filter.type) {
        k = 'type'
        v = filter.type
      } else {
        console.log('unknown filter', filter)
      }

      if (k &amp;&amp; v) {
        if (k in query) {
          if (!('$and' in query[k])) {
            query[k] = { $and: [ query[k] ] }
          }
          query[k].$and.push(v)
        } else {
          query[k] = v
        }
      }
    })

    return query
  }
}

module.exports = Filter
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Filter.html">Filter</a></li><li><a href="KnownArea.html">KnownArea</a></li><li><a href="OverpassFrontend.html">OverpassFrontend</a></li><li><a href="OverpassNode.html">OverpassNode</a></li><li><a href="OverpassObject.html">OverpassObject</a></li><li><a href="OverpassRelation.html">OverpassRelation</a></li><li><a href="OverpassWay.html">OverpassWay</a></li><li><a href="Request.html">Request</a></li><li><a href="RequestBBox.html">RequestBBox</a></li><li><a href="RequestGet.html">RequestGet</a></li></ul><h3>Events</h3><ul><li><a href="OverpassFrontend.html#event:error">error</a></li><li><a href="OverpassFrontend.html#event:load">load</a></li><li><a href="OverpassFrontend.html#event:update">update</a></li><li><a href="Request.html#event:abort">abort</a></li><li><a href="Request.html#event:finish">finish</a></li><li><a href="Request.html#event:subrequest-compiile">subrequest-compiile</a></li><li><a href="Request.html#event:subrequest-finished">subrequest-finished</a></li><li><a href="RequestBBox.html#event:abort">abort</a></li><li><a href="RequestBBox.html#event:finish">finish</a></li><li><a href="RequestBBox.html#event:subrequest-compiile">subrequest-compiile</a></li><li><a href="RequestBBox.html#event:subrequest-finished">subrequest-finished</a></li><li><a href="RequestGet.html#event:abort">abort</a></li><li><a href="RequestGet.html#event:finish">finish</a></li><li><a href="RequestGet.html#event:subrequest-compiile">subrequest-compiile</a></li><li><a href="RequestGet.html#event:subrequest-finished">subrequest-finished</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sat Oct 06 2018 22:54:44 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
